<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Web Memory</title>
	
		<!-- <link rel="stylesheet" href="https://ttmorley-su.github.io/ist263/project/main.css"> -->
	
	
	
</head>
<body>
	<div class="content">
		<nav>
			<!-- <button class="back"></button> -->
			<a class="title" href=https://ttmorley-su.github.io/ist263/project/>Web Memory</a>
		</nav>
		
	<aside>
		<h3>Table of Contents</h3>
		
		    <ul>
			    
			        <li>
			            <a href="https://ttmorley-su.github.io/ist263/project/memory/#introduction-to-memory">Introduction to Memory</a>
			            
			        </li>
			    
		    </ul>
		
	</aside>
	<main>
		<h1 id="introduction-to-memory">Introduction to Memory</h1>
<p>Memory management boils down to allocating and deallocating bytes. But what is memory you may ask? Well, a very naive way of thinking about memory is as an array of bytes. With this array you can store whatever data you need in it (assuming it has enough space for it). However, you shouldn’t just go writing bytes just anywhere in this array. Instead, you’ll need an allocator to tell you where you can write to. An allocator’s whole intention is to keep track of what areas of memory are available for use. The standard approach to this is allocating and deallocating memory. In C, this is done through the <code>malloc</code> (short for memory allocate) and <code>free</code> functions respectively. <code>malloc</code> takes the number of bytes you want as an argument and returns the index in memory you can write to. This index is commonly referred to as a pointer.</p>
<p>For example, here’s a basic C program that creates a string that is 3 bytes, prints it, and then frees it:</p>
<pre data-lang="c" class="language-c "><code class="language-c" data-lang="c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main() {
  &#x2F;&#x2F; C strings end with null, so we need 3 bytes instead of just 2
  char *string = malloc(3); &#x2F;&#x2F; get a pointer to 3 bytes in memory
  string[0] = &#x27;H&#x27;;
  string[1] = &#x27;i&#x27;;
  string[2] = &#x27;\0&#x27;; &#x2F;&#x2F; add the null char to make this a valid C string
  puts(string); &#x2F;&#x2F; this logs the string into the console
  free(string); &#x2F;&#x2F; we no longer need the string, so free up its memory
  return 0;
}
</code></pre>
<p>This program perfectly manages the memory it uses, it allocates only what it needs and frees it up when its no longer needed. Some people may be afraid of having this level of control, but it offers lots of potential optimizations. So, how does this impact the web? Why should you know this? Well, being able to understand the impacts of each function you use is a very important thing if you want to write good websites. While you can’t access the allocator directly from JavaScript, the browser can. It’ll manage everything for you — via the process of garbage collection. Which is basically a fancy term for “any memory that is absolutely unused will get freed”. If you can learn to work with the garbage collector, then you’ll be good at memory management in JavaScript. If you decide to write code for WebAssembly instead, you’ll have complete access to some memory. </p>

		<div class="paging">
			
				<a disabled>Previous</a>
			
			
				<a href=https:&#x2F;&#x2F;ttmorley-su.github.io&#x2F;ist263&#x2F;project&#x2F;wasm&#x2F;>Next</a>
			
		</div>
	</main>

		<footer>
			&copy; 2022
		</footer>
	</div>
</body>
</html>
